# 最短路径算法
最短路径是图论中一个很经典的问题:**给定图 G(VE)，求一条从起点到终点的路径，使得这条路径上经过的所有边的边权之和最小**。对任意给出的图G(VE)和起点S终点T，如何求从S到T的最短路径. 解决最短路径问题的常用算法有**Diikstra算法, Bellman-Ford算法, SPFA算法, Floyd算法**。
## Diikstra算法
* 使用场景: 解决单源路径最短问题, 给定图G和起点s, 通过算法得到s到其他任一顶点的最短距离

* **基本思想**: 设置一个已访问的节点集合S, 从顶点集V中取出初始顶点s加入S, 从V中选择一个距离s最近的顶点u加入S, 以u为中介松弛初始顶点与其他顶点的距离, 这样的松弛操作执行到V为空.

* 有效性分析: 每次都选与源点最近的节点, 也即在对于s到中介点u的路径已经最优(否则可以重新选择使其最优), 在此基础上, 松弛所有未访问的邻居节点, 选择其中一个节点k, 条件是距离s最短, 这样最优路径就扩张了一个节点, 这样的扩张一直到包含所有的节点.

* 复杂度分析: 空间复杂度O(V+E), V为节点数, E为边数(能使用邻接表就使用邻接表), 同时还有个bool having_access[N]以及mincost[N]以及prevnid[N]。从复杂度来看，主要是外层循环 O(V)与内层循环 (寻找最小的 d]需要 O(V)、举v需要 O(adj[u].size))产生的。又由于对整个程序来说，枚举v的次数总共为 O(adj[u]size)=O(E)，因此总复杂度为 O(V+ E)。可以注意到，上面的做法都是复杂度 O(V)级别的，其中由于必须把每个顶点都标记为已访问，因此外层循环的 O(V)时间是无法避免的，但是寻找最小 du]的过程却可以不必达到O(V)的复杂度，而可以使用堆优化来降低复杂度。最简洁的写法是直接使用 STL 中的优先队列priority_queue，这样使用邻接表实现的 Dikstra算法的时间复杂度可以降为0(VlogV+E)此外，Dijkstra 算法只能应对所有边权都是非负数的情况，如果边权出现负数，那么 Dijkstra算法很可能会出错，这时最好使用SPFA算法。

* 出题策略:于是，碰到这种有两条及以上可以达到最短距离的路径，题目就会给出一个第二标尺(第一标尺是距离)，要求在所有最图10-34精灵大陆修改图短路径中选择第二标尺最优的一条路径。而第二标尺常见的是以下三种出题方法或其组合:
给每条边再增加一个边权(比如说花费)，然后要求在最短路径有多条时要求路径上的花费之和最小(如果边权是其他含义，也可以是最大)。
2给每个点增加一个点权(例如每个城市能收集到的物资)，然后在最短路径有多条时要求路径上的点权之和最大《如果点权是其他含义的话也可以是最小)。3 直接问有多少条最短路径
376
第10章提高篇(4)-图算法专题
对这三种出题方法，都只需要增加一个数组来存放新增的边权或点权或最短路径条数，然后在 Dikstra算法中修改优化d[的那个步即可，其他部分不需要改动。


* 注意事项: xxx/

## Bellman-Ford算法

## SPFA算法

## Floyd算法



